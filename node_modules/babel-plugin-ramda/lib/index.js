'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (_ref) {
  var t = _ref.types;

  // Tracking variables build during the AST pass. We instantiate
  // these in the `Program` visitor in order to support running the
  // plugin in watch mode or on multiple files.
  var ramdas = void 0,
      specified = void 0,
      selectedMethods = void 0;

  // Import a ramda method and return the computed import identifier
  function importMethod(methodName, file) {
    if (!selectedMethods[methodName]) {
      var path = (0, _modules2.default)(methodName);
      selectedMethods[methodName] = file.addImport(path, 'default');
    }
    return t.clone(selectedMethods[methodName]);
  }

  function matchesRamda(path, name) {
    return ramdas[name] && hasBindingOfType(path.scope, name, 'ImportDefaultSpecifier');
  }

  function matchesRamdaMethod(path, name) {
    return specified[name] && hasBindingOfType(path.scope, name, 'ImportSpecifier');
  }

  function hasBindingOfType(scope, name, type) {
    return scope.hasBinding(name) && scope.getBinding(name).path.type === type;
  }

  return {
    visitor: {
      Program: {
        enter: function enter() {
          // Track the variables used to import ramda
          ramdas = Object.create(null);
          specified = Object.create(null);
          // Track the methods that have already been used to prevent dupe imports
          selectedMethods = Object.create(null);
        }
      },
      ImportDeclaration: function ImportDeclaration(path) {
        var node = path.node;

        if (node.source.value === 'ramda') {
          node.specifiers.forEach(function (spec) {
            if (t.isImportSpecifier(spec)) {
              specified[spec.local.name] = spec.imported.name;
            } else {
              ramdas[spec.local.name] = true;
            }
          });
          path.remove();
        }
      },
      CallExpression: function CallExpression(path) {
        var node = path.node,
            hub = path.hub;
        var name = node.callee.name;
        var file = hub.file;

        if (!t.isIdentifier(node.callee)) return;
        if (matchesRamdaMethod(path, name)) {
          node.callee = importMethod(specified[name], file);
        }
        if (node.arguments) {
          node.arguments = node.arguments.map(function (arg) {
            var name = arg.name;

            return matchesRamdaMethod(path, name) ? importMethod(specified[name], file) : arg;
          });
        }
      },
      MemberExpression: function MemberExpression(path) {
        var node = path.node;
        var file = path.hub.file;

        var objectName = node.object.name;
        if (!matchesRamda(path, objectName)) return;
        // R.foo() -> foo()
        var newNode = importMethod(node.property.name, file);
        path.replaceWith({ type: newNode.type, name: newNode.name });
      },
      Property: function Property(path) {
        var node = path.node,
            file = path.hub.file;

        if (t.isIdentifier(node.key) && node.computed && matchesRamdaMethod(path, node.key.name)) {
          node.key = importMethod(specified[node.key.name], file);
        }
        if (t.isIdentifier(node.value) && matchesRamdaMethod(path, node.value.name)) {
          node.value = importMethod(specified[node.value.name], file);
        }
      },
      Identifier: function Identifier(path) {
        var node = path.node,
            hub = path.hub,
            parent = path.parent,
            scope = path.scope;
        var name = node.name;
        var file = hub.file;

        if (matchesRamdaMethod(path, name) && !isSpecialTypes(t, parent)) {
          var newNode = importMethod(specified[name], file);
          path.replaceWith({ type: newNode.type, name: newNode.name });
        }
      }
    }
  };
};

var _modules = require('./modules');

var _modules2 = _interopRequireDefault(_modules);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SPECIAL_TYPES = ['isMemberExpression', 'isProperty'];

function isSpecialTypes(t, node) {
  return SPECIAL_TYPES.filter(function (type) {
    return t[type](node);
  }).length > 0;
}